{"pages":[{"title":"关于我","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Ripple Button Demo","text":"button{position:relative;background-color:transparent;border:none;width:120px;height:36px;overflow:hidden;color:#fff;border-radius:4px;outline:0}button>div{position:absolute;background-color:rgba(255,255,255,.4);border-radius:50%}.success{background-color:#04a43b}.info{background-color:#0c9af2}.danger{background-color:#dd0d32}.long{width:200px}.high{height:200px;width:90px}Click Me! Click Me! Click Me!for(var buttons=document.getElementsByTagName(\"button\"),speed=6,i=0;ii?this.offsetWidth-i:i,o=this.offsetHeight-s>s?this.offsetHeight-s:s,n=Math.sqrt(Math.pow(h,2)+Math.pow(o,2));this.children.length?e=this.children[0]:(e=document.createElement(\"div\"),this.appendChild(e));var f=setInterval(function(){e.style.width=e.offsetWidth+speed+\"px\",e.style.height=e.offsetWidth+speed+\"px\",e.style.left=i-e.offsetWidth/2+\"px\",e.style.top=s-e.offsetHeight/2+\"px\",e.style.opacity=e.offsetWidth/n/2,e.offsetWidth>=2*n&&e.offsetHeight>=2*n&&clearInterval(f)},10)},buttons[i].onmouseup=function(t){if(!this.children.length)return!1;t=t||window.event;var e=this,i=this.children[0],s=setInterval(function(){if(i.style.opacity=i.style.opacity-speed/e.offsetWidth,i.style.opacity","link":"/demo/ripple-buttons.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Ripple Button（涟漪按钮）原生JavaScript实现","text":"最近Android 5.0中Ripple Button比较火爆的流行起来，在Web前端中其实现的原理较为简单。本文将尝试通过不使用第三方JavaScript库的情况下结合HTML与CSS实现Web前端中的Ripple Button。点击测试（该示例在Chrome 41.0和IE 9/10/11下测试通过。）HTML和CSS部分代码比较简单：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Ripple Buttons&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* button作为容器，其position需要设置为absolute来承载ripple背景 overflow:hidden用于掩盖ripple超出button的部分 */ button &#123; position: relative; background-color: transparent; border: none; width: 120px; height: 36px; overflow: hidden; color: #fff; border-radius: 4px; outline: none; &#125; /* button中的div为按钮的ripple背景，由JavaScript动态生成 */ button &gt; div &#123; position:absolute; background-color: rgba(255,255,255,0.3); border-radius: 50%; &#125; .success &#123;background-color: #04A43B;&#125; .info &#123;background-color: #0C9AF2;&#125; .danger &#123;background-color: #dd0d32;&#125; .long &#123;height: 200px; width: 90px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=\"success\"&gt;Click Me!&lt;/button&gt; &lt;button class=\"info\"&gt;Click Me!&lt;/button&gt; &lt;button class=\"danger long\"&gt;Click Me!&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;Ripple Button的结构如下图所示：首先我们需要获得用户在button中点击的位置。可以采用onclick事件的offsetX和offsetY来获得用户点击位置相对于被点击的元素的偏移距离，即图中的圆心(x,y)。然后，我们假设按钮ripple背景的半径为Radius，则背景的top和left值可用下面的公式计算：top = y - Radius; left = x - Radius;在计算出ripple的位置之后，下一步需要计算出ripple的最大半径。其最大半径应该满足无论在按钮中的哪一个位置发生点击（也即是无论圆的圆心在何处），都能满足动画完成时按钮的所有部分都被ripple覆盖。所以取圆心到达按钮边界最远的距离为ripple的最大半径（也就是圆心到按钮四个角中最远的距离），计算方法如下：maxRadiusX = max(buttonWidth - x, x);maxRadiusY = max(buttonHeight - y, y);maxRadius = sqrt(maxRadiusX^2 + maxRadiusY^2);现在知道了ripple背景的位置和最大半径（maxRadius），剩下的工作就只要让圆的半径在一定的时间内从零增长到maxRadius，产生动画效果。在JavaScript中，可以使用setInterval来完成定时重复执行的任务。1setInterval(function, interval);setInterval函数包含两个参数，第一个是你需要执行的函数，另一个是定时的时间间隔（单位为ms）。我们只需每隔很小一段时间将ripple的半径增加一定值，就可以实现ripple的动态变大效果了。但是需要注意的是，当ripple的半径达到最大值时，需要使用clearInterval来取消定时器来终止动画。最终，我们将整个动画事件绑定到button的mousedown事件上，这样当用户按下按钮时，按钮上就会产生涟漪效果。同理，我们可以在button的mouseup事件中绑定ripple的消失动画。Ripple的消失动画同样通过setInterval来完成。每隔一定时间，ripple的透明度就会减少一定值，直到ripple完全透明。完整的JavaScript代码如下：1234567891011121314151617181920212223242526272829303132333435var buttons = document.getElementsByTagName('button'), speed = 8;for (var i = 0; i &lt; buttons.length; i++) &#123; buttons[i].onmousedown = function (e) &#123; var e = e || window.event, offsetX = e.offsetX, offsetY = e.offsetY, radiusX = (this.offsetWidth - offsetX &gt; offsetX?this.offsetWidth - offsetX:offsetX), radiusY = (this.offsetHeight - offsetY &gt; offsetY?this.offsetHeight - offsetY:offsetY), offsetSize = Math.sqrt(Math.pow(radiusX,2) + Math.pow(radiusY,2)), inner = document.createElement('div'); this.appendChild(inner); var interval = setInterval(function () &#123; inner.style.width = (inner.offsetWidth + speed) + 'px'; inner.style.height = (inner.offsetWidth + speed) + 'px'; inner.style.left = (offsetX - inner.offsetWidth/2) + 'px'; inner.style.top = (offsetY - inner.offsetHeight/2) + 'px'; inner.style.opacity = inner.offsetWidth/offsetSize/2; if(inner.offsetWidth &gt;= offsetSize*2 &amp;&amp; inner.offsetHeight &gt;= offsetSize*2) &#123; clearInterval(interval); &#125; &#125;, 10); &#125; buttons[i].onmouseup = function (e) &#123; var e = e || window.event, this_ = this, inner = this.children[0]; var interval = setInterval(function () &#123; inner.style.opacity = inner.style.opacity - speed/this_.offsetWidth; if(inner.style.opacity &lt;= 0) &#123; this_.removeChild(inner); clearInterval(interval); &#125; &#125;, 10); &#125;&#125;;点击测试","link":"/2015/03/26/JavaScript-Ripple-Button/"},{"title":"传统轮询、长轮询、服务器发送事件与WebSocket","text":"构建网络应用的过程中，我们经常需要与服务器进行持续的通讯以保持双方信息的同步。通常这种持久通讯在不刷新页面的情况下进行，消耗一定的内存资源常驻后台，并且对于用户不可见。本文将简要介绍Web通信中常用的四种方式。传统轮询(Traditional Polling)当前Web应用中较常见的一种持续通信方式，通常采取setInterval或者setTimeout实现。例如如果我们想要定时获取并刷新页面上的数据，可以结合Ajax写出如下实现：12345setInterval(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); &#125;);&#125;, 10000);上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的缺陷：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。于是出现了采用setTimeout的轮询方式：123456789function poll() &#123; setTimeout(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); // 发起下一次请求 poll(); &#125;); &#125;, 10000);&#125;程序首先设置10秒后发起请求，当数据返回后再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。长轮询(Long Polling)上面两种传统的轮询方式都存在一个严重缺陷：程序在每次请求时都会新建一个HTTP请求，然而并不是每次都能返回所需的新数据。当同时发起的请求达到一定数目时，会对服务器造成较大负担。这时我们可以采用长轮询方式解决这个问题。注意长轮询与以下将要提到的服务器发送事件和WebSocket不能仅仅依靠客户端JavaScript实现，我们同时需要服务器支持并实现相应的技术。长轮询的基本思想是在每次客户端发出请求后，服务器检查上次返回的数据与此次请求时的数据之间是否有更新，如果有更新则返回新数据并结束此次连接，否则服务器“hold”住此次连接，直到有新数据时再返回相应。而这种长时间的保持连接可以通过设置一个较大的HTTP timeout实现。下面是一个简单的长连接示例：服务器（PHP）：1234567891011121314151617181920212223&lt;?php // 示例数据为data.txt $filename= dirname(__FILE__).\"/data.txt\"; // 从请求参数中获取上次请求到的数据的时间戳 $lastmodif = isset( $_GET[\"timestamp\"])? $_GET[\"timestamp\"]: 0 ; // 将文件的最后一次修改时间作为当前数据的时间戳 $currentmodif = filemtime($filename); // 当上次请求到的数据的时间戳*不旧于*当前文件的时间戳，使用循环\"hold\"住当前连接，并不断获取文件的修改时间 while ($currentmodif &lt;= $lastmodif) &#123; // 每次刷新文件信息的时间间隔为10秒 usleep(10000); // 清除文件信息缓存，保证每次获取的修改时间都是最新的修改时间 clearstatcache(); $currentmodif = filemtime($filename); &#125; // 返回数据和最新的时间戳，结束此次连接 $response = array(); $response[\"msg\"] =Date(\"h:i:s\").\" \".file_get_contents($filename); $response[\"timestamp\"]= $currentmodif; echo json_encode($response);?&gt;客户端：12345678910111213141516function longPoll (timestamp) &#123; var _timestamp; $.get(\"/path/to/server?timestamp=\" + timestamp) .done(function(res) &#123; try &#123; var data = JSON.parse(res); console.log(data.msg); _timestamp = data.timestamp; &#125; catch (e) &#123;&#125; &#125;) .always(function() &#123; setTimeout(function() &#123; longPoll(_timestamp || Date.now()/1000); &#125;, 10000); &#125;);&#125;长轮询可以有效地解决传统轮询带来的带宽浪费，但是每次连接的保持是以消耗服务器资源为代价的。尤其对于Apache+PHP服务器，由于有默认的“worker threads”数目的限制，当长连接较多时，服务器便无法对新请求进行相应。服务器发送事件(Server-Sent Event)服务器发送事件（以下简称SSE）是HTML 5规范的一个组成部分，可以实现服务器到客户端的单向数据通信。通过SSE，客户端可以自动获取数据更新，而不用重复发送HTTP请求。一旦连接建立，“事件”便会自动被推送到客户端。服务器端SSE通过“事件流(Event Stream)”的格式产生并推送事件。事件流对应的MIME类型为“text/event-stream”，包含四个字段：event、data、id和retry。event表示事件类型，data表示消息内容，id用于设置客户端EventSource对象的“last event ID string”内部属性，retry指定了重新连接的时间。服务器（PHP）：12345678910111213&lt;?php header(\"Content-Type: text/event-stream\"); header(\"Cache-Control: no-cache\"); // 每隔1秒发送一次服务器的当前时间 while (1) &#123; $time = date(\"r\"); echo \"event: ping\\n\"; echo \"data: The server time is: &#123;$time&#125;\\n\\n\"; ob_flush(); flush(); sleep(1); &#125;?&gt;客户端中，SSE借由EventSource对象实现。EventSource包含五个外部属性：onerror, onmessage, onopen, readyState、url，以及两个内部属性：“reconnection time”与“last event ID string”。在onerror属性中我们可以对错误捕获和处理，而onmessage则对应着服务器事件的接收和处理。另外也可以使用addEventListener方法来监听服务器发送事件，根据event字段区分处理。客户端：12345678var eventSource = new EventSource(\"/path/to/server\");eventSource.onmessage = function (e) &#123; console.log(e.event, e.data);&#125;// 或者eventSource.addEventListener(\"ping\", function(e) &#123; console.log(e.event, e.data);&#125;, false);SSE相较于轮询具有较好的实时性，使用方法也非常简便。然而SSE只支持服务器到客户端单向的事件推送，而且所有版本的IE（包括到目前为止的Microsoft Edge）都不支持SSE。如果需要强行支持IE和部分移动端浏览器，可以尝试EventSource Polyfill（本质上仍然是轮询）。SSE的浏览器支持情况如下图所示：WebSocketWebSocket同样是HTML 5规范的组成部分之一，现标准版本为RFC 6455。WebSocket相较于上述几种连接方式，实现原理较为复杂，用一句话概括就是：客户端向WebSocket服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。由于WebSocket本身是基于TCP协议的，所以在服务器端我们可以采用构建TCP Socket服务器的方式来构建WebSocket服务器。这里为了略过协议解析的具体细节，我们采用Node.js的ws库来实现简单的WebSocket服务器。服务器（Node.js）：123456789var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123;port: 8080&#125;);wss.on(\"connection\", function(socket) &#123; socket.on(\"message\", function(msg) &#123; console.log(msg); socket.send(\"Nice to meet you!\"); &#125;);&#125;);客户端同样可以使用Node.js或者是浏览器实现，这里选用浏览器作为客户端：12345678// WebSocket 为客户端JavaScript的原生对象var ws = new WebSocket(\"ws://localhost:8080\");ws.onopen = function (event) &#123; ws.send(\"Hello there!\");&#125;ws.onmessage = function (event) &#123; console.log(event.data);&#125;WebSocket同样具有实时性，每次通讯无需重发请求头部，节省带宽，而且它的浏览器支持非常好（详见下图）。下面总结一下四种通信方式的优缺点：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;传统轮询长轮询服务器发送事件WebSocket浏览器支持几乎所有现代浏览器几乎所有现代浏览器Firefox 6+ Chrome 6+ Safari 5+ Opera 10.1+IE 10+ Edge Firefox 4+ Chrome 4+ Safari 5+ Opera 11.5+服务器负载较少的CPU资源，较多的内存资源和带宽资源与传统轮询相似，但是占用带宽较少与长轮询相似，除非每次发送请求后服务器不需要断开连接无需循环等待（长轮询），CPU和内存资源不以客户端数量衡量，而是以客户端事件数衡量。四种方式里性能最佳。客户端负载占用较多的内存资源与请求数。与传统轮询相似。浏览器中原生实现，占用资源很小。同Server-Sent Event。延迟非实时，延迟取决于请求间隔。同传统轮询。非实时，默认3秒延迟，延迟可自定义。实时。实现复杂度非常简单。需要服务器配合，客户端实现非常简单。需要服务器配合，而客户端实现甚至比前两种更简单。需要Socket程序实现和额外端口，客户端实现简单。最后分享一个通（ji）俗（qi）易（dou）懂（bi）的介绍轮询和WebSocket的文章：知乎：WebSocket 是什么原理？为什么可以实现持久连接？;","link":"/2015/10/22/Web-Connectivity/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Server","slug":"Server","link":"/tags/Server/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"JavaScript","slug":"Front-End/JavaScript","link":"/categories/Front-End/JavaScript/"}]}